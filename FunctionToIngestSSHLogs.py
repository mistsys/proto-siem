from __future__ import print_function
import logging
import json
import boto3
import logging
import json
import gzip
from StringIO import StringIO
from botocore.vendored import requests
import datetime
import os

logger = logging.getLogger(__name__)
logging.getLogger().setLevel(logging.INFO)

import re
time_fmt = '%Y-%m-%d %H:%M:%S'
ip_regex = r"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b"

#Ingnore logs generated by follwoing utility
ignore_list = ["cron","input_userauth_request","reverse mapping checking getaddrinfo"]

# TODO: Handle API Calls and Build Cached Solution For Queries

def getIPInfo(address, access_key):
    geoip  = {"city_name":None,"region_name":None,"location": None,
          "country_name":None,"latitude":None,"longitude":None}
          
    api = "http://api.ipstack.com/"
    request_string=api+address+"?access_key="+access_key
    try:
        response = requests.get(request_string)
    except:
        return geoip
    
    json_response = json.loads(response.text)
    geoip ["city_name"]=str(json_response["city"])
    geoip ["region_name"]=str(json_response["region_name"])
    geoip ["location"]=[json_response["longitude"],json_response["latitude"]]
    geoip ["latitude"]=json_response["latitude"]
    geoip ["longitude"]=json_response["longitude"]
    geoip ["country_name"]=str(json_response["country_name"])
    return geoip

def parseSSHLog(message):
    logData = {}
    if "Accepted publickey" in message:
        logData['logType']="SuccessfulLoginKey"
        logData['IP']=re.findall(ip_regex,message)[0]
        logData['user']=re.findall(r"for(.*?)from",message)[0].strip()
    elif "Accepted password" in message:
        logData['logType']="SuccessfulLoginPassword"
        logData['IP']=re.findall(ip_regex,message)[0]
        logData['user']=re.findall(r"for(.*?)from",message)[0].strip()
    elif "Received disconnect" in message:
        logData['logType']="PossiblePortScanningAttempt"
        logData['IP']=re.findall(ip_regex,message)[0]
    elif "Invalid user" in message:
        logData['logType']="FailedLogin"
        logData['user']=re.findall(r"user(.*?)from",message)[0].strip()
        logData['IP']=re.findall(ip_regex,message)[0]
        logData['geoip']=getIPInfo(logData['IP'], os.environ['GEOIP_KEY'])
    elif "maximum authentication attempts" in message:
        logData['logType']="MaxAuthTries"
        logData['user']=re.findall(r"user(.*?)from",message)[0].strip()
        logData['IP']=re.findall(ip_regex,message)[0]
        # logData['geoip']=getIPInfo(logData['IP'], os.environ['GEOIP_KEY'])
    elif "Connection closed" in message:
        logData['logType']="ConnectionClosed"
        logData['IP']=re.findall(ip_regex,message)[0]
    else:
        logData['logType']="SSHDefault"
    
    return logData


# parse a command from message when SUDO command available
def parseCmd(line):
    # parse command to end of line 
    cmd = re.search(r'(\bCOMMAND=)(.+?$)', line)
    if cmd is not None:
        return cmd.group(2)
    
# parse an IP from a line
def parseIP(line):
    ip = re.search(r'(\bfrom\s)(\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b)', line)
    if ip is not None:
        return ip.group(2)

def lambda_handler(event, context):
    #CloudWatch log data
    outEvent = str(event['awslogs']['data'])
    
    #decode,unzip
    outEvent = gzip.GzipFile(fileobj=StringIO(outEvent.decode('base64','strict'))).read()
    
    #JSON to dictionary log_data
    cleanEvent = json.loads(outEvent)
    
    
    
    for logEvent in cleanEvent['logEvents']:
        logData = {"notification":"EC2_AUTH_LOGS","isSSHLog":False}
        logData['source']=logEvent['extractedFields']['source']
        message=logEvent['extractedFields']['eventdata']
        logData['eventTimestamp']=logEvent['extractedFields']['month']+" "+logEvent['extractedFields']['date']+" "+logEvent['extractedFields']['time']
        utility=logEvent['extractedFields']['process']
        
        if re.compile('|'.join(ignore_list),re.IGNORECASE).search(utility):
            continue
        if re.compile('|'.join(ignore_list),re.IGNORECASE).search(message):
            continue
        
        if "sshd" in utility:
            logData['isSSHLog']=True
            logData.update(parseSSHLog(message))
        elif "sudo" in utility:
            logData['sudoCommand']=parseCmd(message)
            if (logData['sudoCommand']):
                logData['logType']="sudo"
                logData['user']=message.split()[0]
        else:
            logData['logType']=re.findall(r'^[a-zA-Z0-9-_]+', utility)[0]
        logData['message']=message
        
        print(json.dumps(logData))


