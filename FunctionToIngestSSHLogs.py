from __future__ import print_function
import logging
import json
import boto3
import logging
import json
import gzip
from StringIO import StringIO
from botocore.vendored import requests
import datetime
import os
from boto3 import client as boto3_client
import socket,struct

logger = logging.getLogger(__name__)
logging.getLogger().setLevel(logging.INFO)

import re
time_fmt = '%Y-%m-%d %H:%M:%S'
ip_regex = r"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b"

#Ingnore logs generated by follwoing utility
ignore_list = ["cron","input_userauth_request","reverse mapping checking getaddrinfo"]

# TODO: Handle API Calls and Build Cached Solution For Queries

def fetchGeoIPData(address):
    '''
    Function to Fetch GeoIP data for an IP address
    Args:
        address(string): IP address to be looked up in the database 
    Returns:
        geoip response from Lambda Function
    '''
    lambda_client = boto3_client('lambda')
    response = lambda_client.invoke(
            FunctionName="FunctionToFetchGeoIPData",
            InvocationType='RequestResponse',
            Payload=json.dumps(address)
        )
    
    string_response = response["Payload"].read().decode('utf-8')
    
    parsed_response = json.loads(string_response)

    try:
        if (parsed_response['statusCode']==200):
            geoipresponse = {}
            geoipresponse = json.loads(parsed_response["body"])
            return geoipresponse
    except:
        pass
    
    return None

def parseSSHLog(message):
    '''
    Function to parse and classify SSH message
    Args:
        message(string): message to be parsed
    Returns:
        normalized message as logData
    '''
    logData = {}
    if "Accepted publickey" in message:
        logData['logType']="SuccessfulLoginKey"
        logData['IP']=re.findall(ip_regex,message)[0]
        # logData['geoip']=getIPInfo(logData['IP'], os.environ['GEOIP_KEY'])
        logData['geoip']=fetchGeoIPData(logData['IP'])
        logData['user']=re.findall(r"for(.*?)from",message)[0].strip()
    elif "Accepted password" in message:
        logData['logType']="SuccessfulLoginPassword"
        logData['IP']=re.findall(ip_regex,message)[0]
        logData['user']=re.findall(r"for(.*?)from",message)[0].strip()
    elif "Received disconnect" in message:
        logData['logType']="PossiblePortScanningAttempt"
        logData['IP']=re.findall(ip_regex,message)[0]
    elif "Invalid user" in message:
        logData['logType']="FailedLogin"
        logData['user']=re.findall(r"user(.*?)from",message)[0].strip()
        logData['IP']=re.findall(ip_regex,message)[0]
        logData['geoip']=fetchGeoIPData(logData['IP'])
    elif "maximum authentication attempts" in message:
        logData['logType']="MaxAuthTries"
        logData['user']=re.findall(r"user(.*?)from",message)[0].strip()
        logData['IP']=re.findall(ip_regex,message)[0]
        # logData['geoip']=getIPInfo(logData['IP'], os.environ['GEOIP_KEY'])
    elif "Connection closed" in message:
        logData['logType']="ConnectionClosed"
        logData['IP']=re.findall(ip_regex,message)[0]
    else:
        logData['logType']="SSHDefault"
    
    return logData


# parse a command from message when SUDO command available
def parseCmd(line):
    # parse command to end of line 
    cmd = re.search(r'(\bCOMMAND=)(.+?$)', line)
    if cmd is not None:
        return cmd.group(2)
    
# parse an IP from a line
def parseIP(line):
    ip = re.search(r'(\bfrom\s)(\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b)', line)
    if ip is not None:
        return ip.group(2)

def lambda_handler(event, context):
    #CloudWatch log data
    outEvent = str(event['awslogs']['data'])
    
    #decode,unzip
    outEvent = gzip.GzipFile(fileobj=StringIO(outEvent.decode('base64','strict'))).read()
    
    #JSON to dictionary log_data
    cleanEvent = json.loads(outEvent)
    
    
    sendLogs = {}
    for logEvent in cleanEvent['logEvents']:
        logData = {"notification":"authlog-","isSSHLog":False}
        logData['source']=logEvent['extractedFields']['source']
        message=logEvent['extractedFields']['eventdata']
        logData['eventTimestamp']=logEvent['extractedFields']['month']+" "+logEvent['extractedFields']['date']+" "+logEvent['extractedFields']['time']
        utility=logEvent['extractedFields']['process']
        
        if re.compile('|'.join(ignore_list),re.IGNORECASE).search(utility):
            continue
        if re.compile('|'.join(ignore_list),re.IGNORECASE).search(message):
            continue
        
        if "sshd" in utility:
            logData['isSSHLog']=True
            logData.update(parseSSHLog(message))
        elif "sudo" in utility:
            logData['sudoCommand']=parseCmd(message)
            if (logData['sudoCommand']):
                logData['logType']="sudo"
                logData['user']=message.split()[0]
        else:
            logData['logType']=re.findall(r'^[a-zA-Z0-9-_]+', utility)[0]
        logData['message']=message
        
        print(json.dumps(logData))
